# -*- coding: utf-8 -*-
"""A01275416_PF.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1vZXMMxt8trACOa3qByT39RUaDkwEuEJg

# Graph Coloring Problem - Proyecto Final
## Inteligencia computacional
### A01275416 - Donaldo Alfredo Garrido Islas


El Problema de Coloreado de Gráficos (Graph Coloring Problem) consiste en asignar colores a ciertos elementos de un grafo sujeto a ciertas restricciones. En este código se usa un algoritmo genético para resolver el problema y encontrar el número mínimo de colores requeridos para colorear un grafo.

La coloración de grafos es una asignación de etiquetas, tradicionalmente llamadas "colores", a los vértices de un gráfo sujeto a la condición de que no se asigne la misma etiqueta/color a dos vértices incidentes con un borde. El menor número de colores necesarios para colorear un grafo G se conoce como su número cromático. Una coloración que utiliza como máximo n colores se denomina n-coloración. Un grafo al que se le puede asignar una n-coloración es n-coloreable.

El algoritmo inicia con  con un tope máximo de colores *k*, cuande se encuentra una coloración válida con esta cantidad de colores, se decrementa la cantida de colores a *k-1*. El proceso es repetido hasta que no es posible encontrar una coloración válida para el número dado de colores.
"""

# Instalamos librería para visualización de grafos
!pip install networkx

# Importamos las librerías necesarias
import numpy as np
import pandas as pd
import random

import plotly.graph_objects as go
import plotly.express as px

from array import *

# Creamos los grafos

n = 20
grafos = []

for ii in range(n):
  vertices = []
  for jj in range(n):
    vertices.append(random.randint(0,1))
  grafos.append(vertices)

# Hacemos simétrica la matriz de conexiones
for ii in range(n):
  for jj in range(ii, n):
    grafos[ii][jj] = grafos[jj][ii]

for ii in range(n):
  grafos[ii][ii] = 0

for grafo in grafos:
	print(grafo)

"""## Diagrama de los grafos"""

node_list = list(range(n))
from_list = []
to_list = []

for ii in range(n):
  for jj in range(ii,n):
    if grafos[ii][jj] == 1:
      from_list.append(ii)
      to_list.append(jj)

# Importamos la librería para los grafos
import networkx as nx
import plotly.graph_objs as go
G = nx.Graph()

lst_color = []
for i in range(len(node_list)):
  G.add_node(node_list[i])
  lst_color.append('#888')


for i in range(len(from_list)):
  G.add_edges_from([(from_list[i], to_list[i])])

# Plantilla para grafo circulares (mejor visualización)
pos = nx.circular_layout(G)
for m, p in pos.items():
    G.nodes[m]['pos'] = p

# Creamos la traza de las aristas
edge_trace = go.Scatter(
    x=[],
    y=[],
    line=dict(width=0.5, color='#888'),
    hoverinfo='none',
    mode='lines')
for edge in G.edges():
    x0, y0 = G.nodes[edge[0]]['pos']
    x1, y1 = G.nodes[edge[1]]['pos']
    edge_trace['x'] += tuple([x0, x1, None])
    edge_trace['y'] += tuple([y0, y1, None])

# Creamos la traza de los nodos
node_trace = go.Scatter(
    x=[],
    y=[],
    text=[],
    mode='markers+text',
    hoverinfo='text',
    # Aquí va el color de los nodos
    marker=dict(
        showscale=False,
        reversescale=False,
        color=lst_color,
        size=37,
        colorbar=dict(
            thickness=1,
            title='Node Connections',
            xanchor='left',
            titleside='right'
        ),
        line=dict(width=0)))
for node in G.nodes():
    x, y = G.nodes[node]['pos']
    node_trace['x'] += tuple([x])
    node_trace['y'] += tuple([y])

for node, adjacencies in enumerate(G.adjacency()):
    node_trace['marker']['color'] += tuple([len(adjacencies[1])])
    node_info = adjacencies[0]
    node_trace['text'] += tuple([node_info])

# Graficamos el grafo sin colorear
title = "Grafo orifinal sin colorear ({} nodos)".format(n)
fig = go.Figure(data=[edge_trace, node_trace],
            layout=go.Layout(
            title=title, width=700, height=600,
            titlefont=dict(size=16),
            showlegend=False,
            hovermode='closest',
            margin=dict(b=21, l=5, r=5, t=40),
            xaxis=dict(showgrid=False, zeroline=False,
                       showticklabels=False, mirror=True),
            yaxis=dict(showgrid=False, zeroline=False,
showticklabels=False, mirror=True)))
fig.show()

"""## Algoritmo Genético para recolver el porblema"""

max_colors = 1

for ii in range(n):
  if sum(grafos[ii]) > max_colors:
    max_colors = sum(grafos[ii])+1
max_colors

# Definición de funciones

# Función para la creación de individuos
def individuals_creation_Func(n_colores, n):
  indiv = []

  for ii in range(n):
    indiv.append(random.randint(1,n_colores))

  return indiv


# Función para los pesos
def fitness_Func(grafo, individuo, n):
  fitness = 0

  for ii in range(n):
    for jj in range(ii, n):
      if individuo[ii] == individuo[jj] and grafo[ii][jj]==1:
        fitness += 1

  return fitness


# Función para el cruce
def cruce_Func(padre_1, padre_2, n):
  hijo_1 = []
  hijo_2 = []
  posicion_cruce = random.randint(2,n-2) # Revisar, creo que se puede con 1, n-1
  
  for ii in range(posicion_cruce+1):
    hijo_1.append(padre_1[ii])
    hijo_2.append(padre_2[ii])

  for jj in range(posicion_cruce+1, n):
    hijo_1.append(padre_2[jj])
    hijo_2.append(padre_1[jj])

  return hijo_1, hijo_2


# Función para la mutación
def mutacion_Func(p, individuo, n_colores):
  n_random = random.uniform(0, 1)
  if n_random <= p:
    posicion = random.randint(0, n-1)
    individuo[posicion] = random.randint(1, n_colores)
  return individuo

# Función para la selección
# Se usa una selección de rueda de ruleta
def seleccion_Func(poblacion, grafo, n):
  fitness_tot = 0
  fitness_cum = []
  fitness_cum_sum = 0

  for pop in poblacion:
    fitness_tot += 1/(1+fitness_Func(grafo, pop, n))

  for ii in range(len(poblacion)):
    fitness_cum_sum += 1 / (1+fitness_Func(grafo, poblacion[ii], n))/fitness_tot
    fitness_cum.append(fitness_cum_sum)

  new_poblacion = []

  for ii in range(len(poblacion)):
    ruleta = random.uniform(0, 1)
    for jj in range(len(poblacion)):
      if ruleta <= fitness_cum[jj]:
        new_poblacion.append(poblacion[jj])
        break
  return new_poblacion

num_colors = max_colors
generacion_hist = np.array([])
fit_hist = np.array([])

best_color_number = 0

cut_point = 200

hall_Fame = []


while best_color_number==0 and num_colors>0:
  pop_size = 200
  generacion = 0
  poblacion = []


  # Creamos la población
  for ii in range(pop_size):
    individual = individuals_creation_Func(num_colors, n)
    poblacion.append(individual)

  mejor_fitness = fitness_Func(grafos, poblacion[0], n)
  #print(mejor_fitness)
  fittest_individual = poblacion[0]

  #print(poblacion)

  gen = 0

  while mejor_fitness != 0 and gen != 10000:
    gen += 1
    # Aplicamos la selección
    poblacion = seleccion_Func(poblacion, grafos, n)
    random.shuffle(poblacion)

    new_pop = []

    for ii in range(0, pop_size-1, 2):
      hijo1, hijo2 = cruce_Func(poblacion[ii], poblacion[ii+1], n)

      new_pop.append(hijo1)
      new_pop.append(hijo2)

    for ind in new_pop:
      if gen < cut_point:
        p = 0.5
      else:
        p = 0.25
      ind = mutacion_Func(p, ind, num_colors)

    poblacion = new_pop
    mejor_fitness = fitness_Func(grafos, poblacion[0], n)
    fittest_individual = poblacion[0]

    for ind in poblacion:
      if fitness_Func(grafos, ind, n) < mejor_fitness:
        mejor_fitness = fitness_Func(grafos, ind, n)
        fittest_individual = ind

    enunc_Control = 'Generación: {},   Mejor Fitness: {},   Individuo: {}'
    if gen % 10 == 0:
      
      print(enunc_Control.format(gen, mejor_fitness, fittest_individual))


    generacion_hist = np.append(generacion_hist, gen)
    fit_hist = np.append(fit_hist, mejor_fitness)
    
    if gen >= 1200:
      break

  enunc_no_Colors = 'Usando {} colores'
  enunc_Cromatico = 'El número cromático de este grafo es {}'

  print(enunc_no_Colors.format(num_colors))
  print(enunc_Control.format(gen, mejor_fitness, fittest_individual))
  print('\n')

  hall_Fame.append(fittest_individual)

  if mejor_fitness != 0:
    best_color_number = 1

    cromatic_num = num_colors+1
    print(enunc_Cromatico.format(cromatic_num))
  else:
    generacion_hist = np.append(generacion_hist, gen)
    fit_hist = np.append(fit_hist, mejor_fitness)
    


    fig = go.Figure(data=go.Scatter(x=generacion_hist, y=fit_hist))
    fig.update_layout(title='Fitness usando {} colores'.format(num_colors),
                   xaxis_title='Generación',
                   yaxis_title='Mejor Fitness',
                   width=500, height=400)
    fig.show()

    print('\n \n')
    generacion_hist = np.array([])
    fit_hist = np.array([])
    num_colors -= 1

# Colores finales
final_colors = hall_Fame[-2]

enunc_Mejor_Ind = 'El mejor individuo fue {} \n por lo que se procede a asignar sus colores a los grafos'
print(enunc_Mejor_Ind.format(final_colors))

# Creación aleatoria de los colores
col = []
for ii in range(cromatic_num):
  col.append('#{}{}{}'.format(random.randint(0,9), random.randint(0,9), random.randint(0,9)))


colores = []
for ii in range(len(final_colors)):
  colores.append(col[final_colors[ii]-1])

node_trace = go.Scatter(
    x=[],
    y=[],
    text=[],
    mode='markers+text',
    hoverinfo='text',
    # Aquí va el color de los nodos
    marker=dict(
        showscale=False,
        reversescale=False,
        color=colores,
        size=37,
        colorbar=dict(
            thickness=1,
            title='Node Connections',
            xanchor='left',
            titleside='right'
        ),
        line=dict(width=0)))
for node in G.nodes():
    x, y = G.nodes[node]['pos']
    node_trace['x'] += tuple([x])
    node_trace['y'] += tuple([y])

for node, adjacencies in enumerate(G.adjacency()):
    node_trace['marker']['color'] += tuple([len(adjacencies[1])])
    node_info = adjacencies[0]
    node_trace['text'] += tuple([node_info])

# Graficamos finalmente el grafo con el mínimo de colores posible
title = "Grafo coloreado con el mínimo posible: {} colores ({} nodos)".format(cromatic_num,n)
fig = go.Figure(data=[edge_trace, node_trace],
            layout=go.Layout(
            title=title, width=700, height=600,
            titlefont=dict(size=16),
            showlegend=False,
            hovermode='closest',
            margin=dict(b=21, l=5, r=5, t=40),
            xaxis=dict(showgrid=False, zeroline=False,
                       showticklabels=False, mirror=True),
            yaxis=dict(showgrid=False, zeroline=False,
showticklabels=False, mirror=True)))
fig.show()